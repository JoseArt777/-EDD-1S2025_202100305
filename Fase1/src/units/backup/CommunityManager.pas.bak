unit CommunityManager;

{$mode objfpc}{$H+}

interface

uses
  SysUtils, Classes, DataStructures;

type
  // Estructura para miembro de comunidad
  PCommunityMember = ^TCommunityMember;
  TCommunityMember = record
    UserEmail: String;
    Next: PCommunityMember;
  end;

  // Estructura para comunidad
  PCommunity = ^TCommunity;
  TCommunity = record
    Id: Integer;
    Nombre: String;
    Members: PCommunityMember;  // Lista simple de miembros
    Next: PCommunity;
  end;

// Variables globales
var
  CommunitiesHead: PCommunity;
  CommunityCount: Integer;

// Funciones principales
function CreateCommunity(CommunityName: String): Boolean;
function AddUserToCommunity(CommunityId: Integer; UserEmail: String): Boolean;
function GetCommunitiesHead: PCommunity;
function FindCommunityById(Id: Integer): PCommunity;
function FindCommunityByName(Name: String): PCommunity;
function DeleteCommunity(CommunityId: Integer): Boolean;
function RemoveUserFromCommunity(CommunityId: Integer; UserEmail: String): Boolean;
function IsUserInCommunity(CommunityId: Integer; UserEmail: String): Boolean;
function GetCommunityMembersCount(CommunityId: Integer): Integer;

// Funciones de utilidad
procedure InitializeCommunityManager;
procedure FinalizeCommunityManager;
procedure PrintCommunities;
function GetNextCommunityId: Integer;

implementation

uses
  UserManager; // Para validar que el usuario existe

// ============================================================================
// Inicialización y finalización
// ============================================================================

procedure InitializeCommunityManager;
begin
  CommunitiesHead := nil;
  CommunityCount := 0;
end;

procedure FinalizeCommunityManager;
var
  CurrentCommunity, NextCommunity: PCommunity;
  CurrentMember, NextMember: PCommunityMember;
begin
  CurrentCommunity := CommunitiesHead;

  while CurrentCommunity <> nil do
  begin
    NextCommunity := CurrentCommunity^.Next;

    // Liberar miembros de la comunidad
    CurrentMember := CurrentCommunity^.Members;
    while CurrentMember <> nil do
    begin
      NextMember := CurrentMember^.Next;
      Dispose(CurrentMember);
      CurrentMember := NextMember;
    end;

    // Liberar la comunidad
    Dispose(CurrentCommunity);
    CurrentCommunity := NextCommunity;
  end;

  CommunitiesHead := nil;
  CommunityCount := 0;
end;

// ============================================================================
// Funciones principales
// ============================================================================

function GetCommunitiesHead: PCommunity;
begin
  Result := CommunitiesHead;
end;

function GetNextCommunityId: Integer;
begin
  Inc(CommunityCount);
  Result := CommunityCount;
end;

function CreateCommunity(CommunityName: String): Boolean;
var
  NewCommunity: PCommunity;
begin
  Result := False;

  // Validar nombre
  if Length(Trim(CommunityName)) = 0 then
    Exit;

  // Verificar que no existe una comunidad con el mismo nombre
  if FindCommunityByName(CommunityName) <> nil then
    Exit;

  // Crear nueva comunidad
  New(NewCommunity);
  NewCommunity^.Id := GetNextCommunityId;
  NewCommunity^.Nombre := Trim(CommunityName);
  NewCommunity^.Members := nil;
  NewCommunity^.Next := CommunitiesHead;

  // Agregar al inicio de la lista
  CommunitiesHead := NewCommunity;

  Result := True;
end;

function FindCommunityById(Id: Integer): PCommunity;
var
  Current: PCommunity;
begin
  Result := nil;
  Current := CommunitiesHead;

  while Current <> nil do
  begin
    if Current^.Id = Id then
    begin
      Result := Current;
      Exit;
    end;
    Current := Current^.Next;
  end;
end;

function FindCommunityByName(Name: String): PCommunity;
var
  Current: PCommunity;
begin
  Result := nil;
  Current := CommunitiesHead;

  while Current <> nil do
  begin
    if LowerCase(Current^.Nombre) = LowerCase(Trim(Name)) then
    begin
      Result := Current;
      Exit;
    end;
    Current := Current^.Next;
  end;
end;

function AddUserToCommunity(CommunityId: Integer; UserEmail: String): Boolean;
var
  Community: PCommunity;
  NewMember: PCommunityMember;
begin
  Result := False;

  // Validar email
  if Length(Trim(UserEmail)) = 0 then
    Exit;

  // Buscar la comunidad
  Community := FindCommunityById(CommunityId);
  if Community = nil then
    Exit;

  // Verificar que el usuario no esté ya en la comunidad
  if IsUserInCommunity(CommunityId, UserEmail) then
    Exit;

  // Verificar que el usuario existe (opcional, dependiendo de la implementación de UserManager)
  // if not UserExists(UserEmail) then Exit;

  // Crear nuevo miembro
  New(NewMember);
  NewMember^.UserEmail := Trim(UserEmail);
  NewMember^.Next := Community^.Members;

  // Agregar al inicio de la lista de miembros
  Community^.Members := NewMember;

  Result := True;
end;

function IsUserInCommunity(CommunityId: Integer; UserEmail: String): Boolean;
var
  Community: PCommunity;
  CurrentMember: PCommunityMember;
begin
  Result := False;

  Community := FindCommunityById(CommunityId);
  if Community = nil then
    Exit;

  CurrentMember := Community^.Members;
  while CurrentMember <> nil do
  begin
    if LowerCase(CurrentMember^.UserEmail) = LowerCase(Trim(UserEmail)) then
    begin
      Result := True;
      Exit;
    end;
    CurrentMember := CurrentMember^.Next;
  end;
end;

function RemoveUserFromCommunity(CommunityId: Integer; UserEmail: String): Boolean;
var
  Community: PCommunity;
  CurrentMember, PrevMember: PCommunityMember;
begin
  Result := False;

  Community := FindCommunityById(CommunityId);
  if Community = nil then
    Exit;

  CurrentMember := Community^.Members;
  PrevMember := nil;

  while CurrentMember <> nil do
  begin
    if LowerCase(CurrentMember^.UserEmail) = LowerCase(Trim(UserEmail)) then
    begin
      // Remover de la lista
      if PrevMember = nil then
        Community^.Members := CurrentMember^.Next
      else
        PrevMember^.Next := CurrentMember^.Next;

      Dispose(CurrentMember);
      Result := True;
      Exit;
    end;

    PrevMember := CurrentMember;
    CurrentMember := CurrentMember^.Next;
  end;
end;

function DeleteCommunity(CommunityId: Integer): Boolean;
var
  CurrentCommunity, PrevCommunity: PCommunity;
  CurrentMember, NextMember: PCommunityMember;
begin
  Result := False;

  CurrentCommunity := CommunitiesHead;
  PrevCommunity := nil;

  while CurrentCommunity <> nil do
  begin
    if CurrentCommunity^.Id = CommunityId then
    begin
      // Liberar miembros
      CurrentMember := CurrentCommunity^.Members;
      while CurrentMember <> nil do
      begin
        NextMember := CurrentMember^.Next;
        Dispose(CurrentMember);
        CurrentMember := NextMember;
      end;

      // Remover de la lista de comunidades
      if PrevCommunity = nil then
        CommunitiesHead := CurrentCommunity^.Next
      else
        PrevCommunity^.Next := CurrentCommunity^.Next;

      Dispose(CurrentCommunity);
      Result := True;
      Exit;
    end;

    PrevCommunity := CurrentCommunity;
    CurrentCommunity := CurrentCommunity^.Next;
  end;
end;

function GetCommunityMembersCount(CommunityId: Integer): Integer;
var
  Community: PCommunity;
  CurrentMember: PCommunityMember;
begin
  Result := 0;

  Community := FindCommunityById(CommunityId);
  if Community = nil then
    Exit;

  CurrentMember := Community^.Members;
  while CurrentMember <> nil do
  begin
    Inc(Result);
    CurrentMember := CurrentMember^.Next;
  end;
end;

// ============================================================================
// Funciones de utilidad
// ============================================================================

procedure PrintCommunities;
var
  CurrentCommunity: PCommunity;
  CurrentMember: PCommunityMember;
  MemberCount: Integer;
begin
  WriteLn('=== COMUNIDADES ===');

  if CommunitiesHead = nil then
  begin
    WriteLn('No hay comunidades registradas.');
    Exit;
  end;

  CurrentCommunity := CommunitiesHead;
  while CurrentCommunity <> nil do
  begin
    MemberCount := GetCommunityMembersCount(CurrentCommunity^.Id);
    WriteLn('ID: ', CurrentCommunity^.Id, ' | Nombre: ', CurrentCommunity^.Nombre,
            ' | Miembros: ', MemberCount);

    // Mostrar miembros
    CurrentMember := CurrentCommunity^.Members;
    while CurrentMember <> nil do
    begin
      WriteLn('  - ', CurrentMember^.UserEmail);
      CurrentMember := CurrentMember^.Next;
    end;

    if MemberCount = 0 then
      WriteLn('  (Sin miembros)');

    WriteLn('');
    CurrentCommunity := CurrentCommunity^.Next;
  end;

  WriteLn('Total de comunidades: ', CommunityCount);
end;

// ============================================================================
// Inicialización automática
// ============================================================================

initialization
  InitializeCommunityManager;

finalization
  FinalizeCommunityManager;

end.

