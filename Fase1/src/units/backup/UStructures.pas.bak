unit UStructures;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

type
  // Tipos de datos para el sistema
  
  // Usuario
  PUser = ^TUser;
  TUser = record
    id: Integer;
    nombre: string;
    usuario: string;
    email: string;
    telefono: string;
    password: string;
    siguiente: PUser;
  end;

  // Correo electrónico
  PEmail = ^TEmail;
  TEmail = record
    id: Integer;
    remitente: string;
    destinatario: string;
    estado: string; // 'NL' (No Leído), 'L' (Leído), 'Eliminado'
    programado: Boolean;
    asunto: string;
    fecha: TDateTime;
    mensaje: string;
    siguiente: PEmail;
    anterior: PEmail;
  end;

  // Contacto (Lista circular)
  PContact = ^TContact;
  TContact = record
    id: Integer;
    nombre: string;
    usuario: string;
    email: string;
    telefono: string;
    siguiente: PContact;
  end;

  // Comunidad
  PCommunity = ^TCommunity;
  TCommunity = record
    id: Integer;
    nombre: string;
    usuarios: PUser; // Lista de usuarios en la comunidad
    siguiente: PCommunity;
  end;

  // Nodo para matriz dispersa
  PMatrixNode = ^TMatrixNode;
  TMatrixNode = record
    fila: Integer;
    columna: Integer;
    valor: Integer;
    siguiente_fila: PMatrixNode;
    siguiente_columna: PMatrixNode;
  end;

  // Lista simple de usuarios
  TUserList = class
  private
    FHead: PUser;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure AddUser(id: Integer; nombre, usuario, email, telefono, password: string);
    function FindUser(email: string): PUser;
    function FindUserByUsername(usuario: string): PUser;
    function AuthenticateUser(email, password: string): PUser;
    procedure UpdateUser(user: PUser; nombre, usuario, telefono: string);
    procedure ClearList;
    procedure LoadFromJSON(filename: string);
    
    property Head: PUser read FHead;
    property Count: Integer read FCount;
  end;

  // Lista doblemente enlazada para correos
  TEmailList = class
  private
    FHead: PEmail;
    FTail: PEmail;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure AddEmail(id: Integer; remitente, destinatario, asunto, mensaje: string; 
                      fecha: TDateTime; programado: Boolean = False);
    procedure RemoveEmail(email: PEmail);
    function FindEmail(id: Integer): PEmail;
    procedure MarkAsRead(email: PEmail);
    procedure SortBySubject;
    function GetUnreadCount: Integer;
    procedure ClearList;
    
    property Head: PEmail read FHead;
    property Tail: PEmail read FTail;
    property Count: Integer read FCount;
  end;

  // Lista circular para contactos
  TContactList = class
  private
    FHead: PContact;
    FCount: Integer;
    FCurrent: PContact;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure AddContact(id: Integer; nombre, usuario, email, telefono: string);
    procedure RemoveContact(email: string);
    function FindContact(email: string): PContact;
    function GetNext: PContact;
    function GetPrevious: PContact;
    procedure ClearList;
    
    property Head: PContact read FHead;
    property Count: Integer read FCount;
    property Current: PContact read FCurrent write FCurrent;
  end;

  // Cola para correos programados
  TEmailQueue = class
  private
    FHead: PEmail;
    FTail: PEmail;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure Enqueue(id: Integer; remitente, destinatario, asunto, mensaje: string; fecha: TDateTime);
    function Dequeue: PEmail;
    function IsEmpty: Boolean;
    function GetScheduledEmails: PEmail;
    procedure ClearQueue;
    
    property Head: PEmail read FHead;
    property Count: Integer read FCount;
  end;

  // Pila para correos eliminados
  TEmailStack = class
  private
    FTop: PEmail;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure Push(email: PEmail);
    function Pop: PEmail;
    function IsEmpty: Boolean;
    function SearchBySubject(keyword: string): PEmail;
    procedure ClearStack;
    
    property Top: PEmail read FTop;
    property Count: Integer read FCount;
  end;

  // Lista de comunidades
  TCommunityList = class
  private
    FHead: PCommunity;
    FCount: Integer;
  public
    constructor Create;
    destructor Destroy; override;
    
    procedure AddCommunity(id: Integer; nombre: string);
    procedure AddUserToCommunity(communityId: Integer; user: PUser);
    function FindCommunity(id: Integer): PCommunity;
    procedure ClearList;
    
    property Head: PCommunity read FHead;
    property Count: Integer read FCount;
  end;

  // Matriz dispersa para relaciones
  TSparseMatrix = class
  private
    FHead: PMatrixNode;
    FFilas: array of PMatrixNode;
    FColumnas: array of PMatrixNode;
    FMaxFila: Integer;
    FMaxColumna: Integer;
  public
    constructor Create(maxFila, maxColumna: Integer);
    destructor Destroy; override;
    
    procedure SetValue(fila, columna, valor: Integer);
    function GetValue(fila, columna: Integer): Integer;
    procedure IncrementValue(fila, columna: Integer);
    procedure ClearMatrix;
    
    property MaxFila: Integer read FMaxFila;
    property MaxColumna: Integer read FMaxColumna;
  end;

implementation

uses
  fpjson, jsonparser;

// TUserList Implementation
constructor TUserList.Create;
begin
  inherited Create;
  FHead := nil;
  FCount := 0;
end;

destructor TUserList.Destroy;
begin
  ClearList;
  inherited Destroy;
end;

procedure TUserList.AddUser(id: Integer; nombre, usuario, email, telefono, password: string);
var
  newUser: PUser;
begin
  New(newUser);
  newUser^.id := id;
  newUser^.nombre := nombre;
  newUser^.usuario := usuario;
  newUser^.email := email;
  newUser^.telefono := telefono;
  newUser^.password := password;
  newUser^.siguiente := FHead;
  FHead := newUser;
  Inc(FCount);
end;

function TUserList.FindUser(email: string): PUser;
var
  current: PUser;
begin
  Result := nil;
  current := FHead;
  while current <> nil do
  begin
    if current^.email = email then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  end;
end;

function TUserList.FindUserByUsername(usuario: string): PUser;
var
  current: PUser;
begin
  Result := nil;
  current := FHead;
  while current <> nil do
  begin
    if current^.usuario = usuario then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  end;
end;

function TUserList.AuthenticateUser(email, password: string): PUser;
var
  user: PUser;
begin
  Result := nil;
  user := FindUser(email);
  if (user <> nil) and (user^.password = password) then
    Result := user;
end;

procedure TUserList.UpdateUser(user: PUser; nombre, usuario, telefono: string);
begin
  if user <> nil then
  begin
    user^.nombre := nombre;
    user^.usuario := usuario;
    user^.telefono := telefono;
  end;
end;

procedure TUserList.ClearList;
var
  current, temp: PUser;
begin
  current := FHead;
  while current <> nil do
  begin
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  FHead := nil;
  FCount := 0;
end;

procedure TUserList.LoadFromJSON(filename: string);
var
  jsonData: TJSONData;
  jsonObject: TJSONObject;
  usersArray: TJSONArray;
  userObject: TJSONObject;
  i: Integer;
  fileContent: string;
  fs: TFileStream;
begin
  try
    fs := TFileStream.Create(filename, fmOpenRead);
    try
      SetLength(fileContent, fs.Size);
      fs.ReadBuffer(fileContent[1], fs.Size);
    finally
      fs.Free;
    end;

    jsonData := GetJSON(fileContent);
    try
      jsonObject := jsonData as TJSONObject;
      usersArray := jsonObject.Get('usuarios', TJSONArray(nil));
      
      if usersArray <> nil then
      begin
        for i := 0 to usersArray.Count - 1 do
        begin
          userObject := usersArray.Objects[i];
          AddUser(
            userObject.Get('id', 0),
            userObject.Get('nombre', ''),
            userObject.Get('usuario', ''),
            userObject.Get('email', ''),
            userObject.Get('telefono', ''),
            'default123' // Password por defecto
          );
        end;
      end;
    finally
      jsonData.Free;
    end;
  except
    on E: Exception do
      WriteLn('Error loading JSON: ', E.Message);
  end;
end;

// TEmailList Implementation
constructor TEmailList.Create;
begin
  inherited Create;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

destructor TEmailList.Destroy;
begin
  ClearList;
  inherited Destroy;
end;

procedure TEmailList.AddEmail(id: Integer; remitente, destinatario, asunto, mensaje: string; 
                             fecha: TDateTime; programado: Boolean = False);
var
  newEmail: PEmail;
begin
  New(newEmail);
  newEmail^.id := id;
  newEmail^.remitente := remitente;
  newEmail^.destinatario := destinatario;
  newEmail^.estado := 'NL'; // No leído por defecto
  newEmail^.programado := programado;
  newEmail^.asunto := asunto;
  newEmail^.fecha := fecha;
  newEmail^.mensaje := mensaje;
  newEmail^.siguiente := nil;
  newEmail^.anterior := FTail;
  
  if FTail <> nil then
    FTail^.siguiente := newEmail
  else
    FHead := newEmail;
    
  FTail := newEmail;
  Inc(FCount);
end;

procedure TEmailList.RemoveEmail(email: PEmail);
begin
  if email = nil then Exit;
  
  if email^.anterior <> nil then
    email^.anterior^.siguiente := email^.siguiente
  else
    FHead := email^.siguiente;
    
  if email^.siguiente <> nil then
    email^.siguiente^.anterior := email^.anterior
  else
    FTail := email^.anterior;
    
  Dec(FCount);
end;

function TEmailList.FindEmail(id: Integer): PEmail;
var
  current: PEmail;
begin
  Result := nil;
  current := FHead;
  while current <> nil do
  begin
    if current^.id = id then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  end;
end;

procedure TEmailList.MarkAsRead(email: PEmail);
begin
  if email <> nil then
    email^.estado := 'L';
end;

procedure TEmailList.SortBySubject;
var
  i, j: Integer;
  current, next: PEmail;
  temp: TEmail;
begin
  current := FHead;
  for i := 0 to FCount - 2 do
  begin
    next := current^.siguiente;
    for j := i + 1 to FCount - 1 do
    begin
      if current^.asunto > next^.asunto then
      begin
        // Intercambiar datos (no punteros)
        temp := current^;
        current^.id := next^.id;
        current^.remitente := next^.remitente;
        current^.destinatario := next^.destinatario;
        current^.estado := next^.estado;
        current^.programado := next^.programado;
        current^.asunto := next^.asunto;
        current^.fecha := next^.fecha;
        current^.mensaje := next^.mensaje;
        
        next^.id := temp.id;
        next^.remitente := temp.remitente;
        next^.destinatario := temp.destinatario;
        next^.estado := temp.estado;
        next^.programado := temp.programado;
        next^.asunto := temp.asunto;
        next^.fecha := temp.fecha;
        next^.mensaje := temp.mensaje;
      end;
      next := next^.siguiente;
    end;
    current := current^.siguiente;
  end;
end;

function TEmailList.GetUnreadCount: Integer;
var
  current: PEmail;
begin
  Result := 0;
  current := FHead;
  while current <> nil do
  begin
    if current^.estado = 'NL' then
      Inc(Result);
    current := current^.siguiente;
  end;
end;

procedure TEmailList.ClearList;
var
  current, temp: PEmail;
begin
  current := FHead;
  while current <> nil do
  begin
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

// TContactList Implementation
constructor TContactList.Create;
begin
  inherited Create;
  FHead := nil;
  FCount := 0;
  FCurrent := nil;
end;

destructor TContactList.Destroy;
begin
  ClearList;
  inherited Destroy;
end;

procedure TContactList.AddContact(id: Integer; nombre, usuario, email, telefono: string);
var
  newContact: PContact;
begin
  New(newContact);
  newContact^.id := id;
  newContact^.nombre := nombre;
  newContact^.usuario := usuario;
  newContact^.email := email;
  newContact^.telefono := telefono;
  
  if FHead = nil then
  begin
    FHead := newContact;
    newContact^.siguiente := newContact; // Apunta a sí mismo
    FCurrent := newContact;
  end
  else
  begin
    newContact^.siguiente := FHead^.siguiente;
    FHead^.siguiente := newContact;
  end;
  
  Inc(FCount);
end;

procedure TContactList.RemoveContact(email: string);
var
  current, previous: PContact;
  found: Boolean;
begin
  if FHead = nil then Exit;
  
  found := False;
  current := FHead;
  previous := nil;
  
  repeat
    if current^.email = email then
    begin
      found := True;
      Break;
    end;
    previous := current;
    current := current^.siguiente;
  until current = FHead;
  
  if found then
  begin
    if FCount = 1 then
    begin
      Dispose(FHead);
      FHead := nil;
      FCurrent := nil;
    end
    else
    begin
      if current = FHead then
      begin
        // Encontrar el último nodo para actualizar su siguiente
        previous := FHead;
        while previous^.siguiente <> FHead do
          previous := previous^.siguiente;
        
        FHead := FHead^.siguiente;
        previous^.siguiente := FHead;
        
        if FCurrent = current then
          FCurrent := FHead;
      end
      else
      begin
        previous^.siguiente := current^.siguiente;
        if FCurrent = current then
          FCurrent := current^.siguiente;
      end;
      
      Dispose(current);
    end;
    
    Dec(FCount);
  end;
end;

function TContactList.FindContact(email: string): PContact;
var
  current: PContact;
begin
  Result := nil;
  if FHead = nil then Exit;
  
  current := FHead;
  repeat
    if current^.email = email then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  until current = FHead;
end;

function TContactList.GetNext: PContact;
begin
  if FCurrent <> nil then
  begin
    FCurrent := FCurrent^.siguiente;
    Result := FCurrent;
  end
  else
    Result := nil;
end;

function TContactList.GetPrevious: PContact;
var
  current: PContact;
begin
  Result := nil;
  if (FCurrent = nil) or (FHead = nil) then Exit;
  
  current := FHead;
  repeat
    if current^.siguiente = FCurrent then
    begin
      FCurrent := current;
      Result := FCurrent;
      Break;
    end;
    current := current^.siguiente;
  until current = FHead;
end;

procedure TContactList.ClearList;
var
  current, temp: PContact;
  i: Integer;
begin
  if FHead = nil then Exit;
  
  current := FHead;
  for i := 0 to FCount - 1 do
  begin
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  
  FHead := nil;
  FCurrent := nil;
  FCount := 0;
end;

// TEmailQueue Implementation
constructor TEmailQueue.Create;
begin
  inherited Create;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

destructor TEmailQueue.Destroy;
begin
  ClearQueue;
  inherited Destroy;
end;

procedure TEmailQueue.Enqueue(id: Integer; remitente, destinatario, asunto, mensaje: string; fecha: TDateTime);
var
  newEmail: PEmail;
begin
  New(newEmail);
  newEmail^.id := id;
  newEmail^.remitente := remitente;
  newEmail^.destinatario := destinatario;
  newEmail^.estado := 'Programado';
  newEmail^.programado := True;
  newEmail^.asunto := asunto;
  newEmail^.fecha := fecha;
  newEmail^.mensaje := mensaje;
  newEmail^.siguiente := nil;
  newEmail^.anterior := nil;
  
  if FTail = nil then
  begin
    FHead := newEmail;
    FTail := newEmail;
  end
  else
  begin
    FTail^.siguiente := newEmail;
    FTail := newEmail;
  end;
  
  Inc(FCount);
end;

function TEmailQueue.Dequeue: PEmail;
begin
  Result := nil;
  if FHead <> nil then
  begin
    Result := FHead;
    FHead := FHead^.siguiente;
    if FHead = nil then
      FTail := nil;
    Dec(FCount);
  end;
end;

function TEmailQueue.IsEmpty: Boolean;
begin
  Result := FHead = nil;
end;

function TEmailQueue.GetScheduledEmails: PEmail;
begin
  Result := FHead;
end;

procedure TEmailQueue.ClearQueue;
var
  current, temp: PEmail;
begin
  current := FHead;
  while current <> nil do
  begin
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  FHead := nil;
  FTail := nil;
  FCount := 0;
end;

// TEmailStack Implementation
constructor TEmailStack.Create;
begin
  inherited Create;
  FTop := nil;
  FCount := 0;
end;

destructor TEmailStack.Destroy;
begin
  ClearStack;
  inherited Destroy;
end;

procedure TEmailStack.Push(email: PEmail);
var
  newEmail: PEmail;
begin
  if email = nil then Exit;
  
  New(newEmail);
  newEmail^ := email^;
  newEmail^.estado := 'Eliminado';
  newEmail^.siguiente := FTop;
  newEmail^.anterior := nil;
  FTop := newEmail;
  Inc(FCount);
end;

function TEmailStack.Pop: PEmail;
begin
  Result := nil;
  if FTop <> nil then
  begin
    Result := FTop;
    FTop := FTop^.siguiente;
    Dec(FCount);
  end;
end;

function TEmailStack.IsEmpty: Boolean;
begin
  Result := FTop = nil;
end;

function TEmailStack.SearchBySubject(keyword: string): PEmail;
var
  current: PEmail;
begin
  Result := nil;
  current := FTop;
  while current <> nil do
  begin
    if Pos(LowerCase(keyword), LowerCase(current^.asunto)) > 0 then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  end;
end;

procedure TEmailStack.ClearStack;
var
  current, temp: PEmail;
begin
  current := FTop;
  while current <> nil do
  begin
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  FTop := nil;
  FCount := 0;
end;

// TCommunityList Implementation
constructor TCommunityList.Create;
begin
  inherited Create;
  FHead := nil;
  FCount := 0;
end;

destructor TCommunityList.Destroy;
begin
  ClearList;
  inherited Destroy;
end;

procedure TCommunityList.AddCommunity(id: Integer; nombre: string);
var
  newCommunity: PCommunity;
begin
  New(newCommunity);
  newCommunity^.id := id;
  newCommunity^.nombre := nombre;
  newCommunity^.usuarios := nil;
  newCommunity^.siguiente := FHead;
  FHead := newCommunity;
  Inc(FCount);
end;

procedure TCommunityList.AddUserToCommunity(communityId: Integer; user: PUser);
var
  community: PCommunity;
  newUser: PUser;
begin
  community := FindCommunity(communityId);
  if (community <> nil) and (user <> nil) then
  begin
    New(newUser);
    newUser^ := user^;
    newUser^.siguiente := community^.usuarios;
    community^.usuarios := newUser;
  end;
end;

function TCommunityList.FindCommunity(id: Integer): PCommunity;
var
  current: PCommunity;
begin
  Result := nil;
  current := FHead;
  while current <> nil do
  begin
    if current^.id = id then
    begin
      Result := current;
      Break;
    end;
    current := current^.siguiente;
  end;
end;

procedure TCommunityList.ClearList;
var
  current, temp: PCommunity;
  userCurrent, userTemp: PUser;
begin
  current := FHead;
  while current <> nil do
  begin
    // Limpiar usuarios de la comunidad
    userCurrent := current^.usuarios;
    while userCurrent <> nil do
    begin
      userTemp := userCurrent;
      userCurrent := userCurrent^.siguiente;
      Dispose(userTemp);
    end;
    
    temp := current;
    current := current^.siguiente;
    Dispose(temp);
  end;
  FHead := nil;
  FCount := 0;
end;

// TSparseMatrix Implementation
constructor TSparseMatrix.Create(maxFila, maxColumna: Integer);
var
  i: Integer;
begin
  inherited Create;
  FHead := nil;
  FMaxFila := maxFila;
  FMaxColumna := maxColumna;
  
  SetLength(FFilas, maxFila + 1);
  SetLength(FColumnas, maxColumna + 1);
  
  for i := 0 to maxFila do
    FFilas[i] := nil;
  for i := 0 to maxColumna do
    FColumnas[i] := nil;
end;

destructor TSparseMatrix.Destroy;
begin
  ClearMatrix;
  inherited Destroy;
end;

procedure TSparseMatrix.SetValue(fila, columna, valor: Integer);
var
  current, newNode, prev: PMatrixNode;
begin
  if (fila < 0) or (fila > FMaxFila) or (columna < 0) or (columna > FMaxColumna) then
    Exit;
  
  // Buscar si ya existe el nodo
  current := FFilas[fila];
  while (current <> nil) and (current^.columna < columna) do
    current := current^.siguiente_fila;
  
  if (current <> nil) and (current^.columna = columna) then
  begin
    current^.valor := valor;
    Exit;
  end;
  
  // Crear nuevo nodo
  New(newNode);
  newNode^.fila := fila;
  newNode^.columna := columna;
  newNode^.valor := valor;
  
  // Insertar en fila
  if (FFilas[fila] = nil) or (FFilas[fila]^.columna > columna) then
  begin
    newNode^.siguiente_fila := FFilas[fila];
    FFilas[fila] := newNode;
  end
  else
  begin
    prev := FFilas[fila];
    while (prev^.siguiente_fila <> nil) and (prev^.siguiente_fila^.columna < columna) do
      prev := prev^.siguiente_fila;
    newNode^.siguiente_fila := prev^.siguiente_fila;
    prev^.siguiente_fila := newNode;
  end;
  
  // Insertar en columna
  if (FColumnas[columna] = nil) or (FColumnas[columna]^.fila > fila) then
  begin
    newNode^.siguiente_columna := FColumnas[columna];
    FColumnas[columna] := newNode;
  end
  else
  begin
    prev := FColumnas[columna];
    while (prev^.siguiente_columna <> nil) and (prev^.siguiente_columna^.fila < fila) do
      prev := prev^.siguiente_columna;
    newNode^.siguiente_columna := prev^.siguiente_columna;
    prev^.siguiente_columna := newNode;
  end;
end;

function TSparseMatrix.GetValue(fila, columna: Integer): Integer;
var
  current: PMatrixNode;
begin
  Result := 0;
  if (fila < 0) or (fila > FMaxFila) or (columna < 0) or (columna > FMaxColumna) then
    Exit;
  
  current := FFilas[fila];
  while current <> nil do
  begin
    if current^.columna = columna then
    begin
      Result := current^.valor;
      Break;
    end
    else if current^.columna > columna then
      Break;
    current := current^.siguiente_fila;
  end;
end;

procedure TSparseMatrix.IncrementValue(fila, columna: Integer);
var
  currentValue: Integer;
begin
  currentValue := GetValue(fila, columna);
  SetValue(fila, columna, currentValue + 1);
end;

procedure TSparseMatrix.ClearMatrix;
var
  i: Integer;
  current, temp: PMatrixNode;
begin
  for i := 0 to FMaxFila do
  begin
    current := FFilas[i];
    while current <> nil do
    begin
      temp := current;
      current := current^.siguiente_fila;
      Dispose(temp);
    end;
    FFilas[i] := nil;
  end;
  
  for i := 0 to FMaxColumna do
    FColumnas[i] := nil;
    
  FHead := nil;
end;

end.
