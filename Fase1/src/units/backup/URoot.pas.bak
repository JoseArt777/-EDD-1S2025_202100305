unit URoot;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, UStructures, UUser, UCommunities, UReports;

type
  TRootManager = class
  private
    FUserManager: TUserManager;
    FCommunityManager: TCommunityManager;
    FReportGenerator: TReportGenerator;
    FRelationMatrix: TSparseMatrix;
    FUserIndexMap: TStringList; // Para mapear emails a índices de matriz
    
    procedure InitializeRelationMatrix;
    function GetUserIndex(email: string): Integer;
    procedure UpdateRelationMatrix(senderEmail, receiverEmail: string);
    
  public
    constructor Create(userManager: TUserManager);
    destructor Destroy; override;
    
    // Carga masiva de usuarios
    function LoadUsersFromJSON(filename: string; out errorMsg: string): Boolean;
    
    // Gestión de comunidades
    function CreateCommunity(nombre: string; out errorMsg: string): Boolean;
    function AddUserToCommunity(communityName, userEmail: string; out errorMsg: string): Boolean;
    function ListCommunities: TStringList;
    
    // Generación de reportes
    function GenerateUserReport: Boolean;
    function GenerateRelationReport: Boolean;
    function GenerateCommunitiesReport: Boolean;
    
    // Registro de envío de correos (para matriz de relaciones)
    procedure RegisterEmailSent(senderEmail, receiverEmail: string);
    
    // Getters
    property RelationMatrix: TSparseMatrix read FRelationMatrix;
    property CommunityManager: TCommunityManager read FCommunityManager;
  end;

implementation

uses
  FileUtil;

constructor TRootManager.Create(userManager: TUserManager);
begin
  inherited Create;
  FUserManager := userManager;
  FCommunityManager := TCommunityManager.Create(userManager);
  FReportGenerator := TReportGenerator.Create(userManager, FCommunityManager);
  FUserIndexMap := TStringList.Create;
  FUserIndexMap.Sorted := True;
  FUserIndexMap.Duplicates := dupIgnore;
  
  InitializeRelationMatrix;
end;

destructor TRootManager.Destroy;
begin
  FRelationMatrix.Free;
  FUserIndexMap.Free;
  FReportGenerator.Free;
  FCommunityManager.Free;
  inherited Destroy;
end;

procedure TRootManager.InitializeRelationMatrix;
var
  maxUsers: Integer;
  current: PUser;
  index: Integer;
begin
  // Determinar número máximo de usuarios
  maxUsers := 100; // Tamaño inicial, se puede ajustar dinámicamente
  
  FRelationMatrix := TSparseMatrix.Create(maxUsers, maxUsers);
  
  // Mapear usuarios existentes
  current := FUserManager.Users.Head;
  index := 0;
  while current <> nil do
  begin
    if FUserIndexMap.IndexOf(current^.email) = -1 then
    begin
      FUserIndexMap.AddObject(current^.email, TObject(PtrInt(index)));
      Inc(index);
    end;
    current := current^.siguiente;
  end;
end;

function TRootManager.GetUserIndex(email: string): Integer;
var
  index: Integer;
begin
  index := FUserIndexMap.IndexOf(email);
  if index = -1 then
  begin
    // Agregar nuevo usuario al mapa
    Result := FUserIndexMap.Count;
    FUserIndexMap.AddObject(email, TObject(PtrInt(Result)));
  end
  else
  begin
    Result := PtrInt(FUserIndexMap.Objects[index]);
  end;
end;

procedure TRootManager.UpdateRelationMatrix(senderEmail, receiverEmail: string);
var
  senderIndex, receiverIndex: Integer;
begin
  senderIndex := GetUserIndex(senderEmail);
  receiverIndex := GetUserIndex(receiverEmail);
  
  FRelationMatrix.IncrementValue(senderIndex, receiverIndex);
end;

function TRootManager.LoadUsersFromJSON(filename: string; out errorMsg: string): Boolean;
begin
  Result := False;
  errorMsg := '';
  
  try
    if not FileExists(filename) then
    begin
      errorMsg := 'El archivo ' + filename + ' no existe';
      Exit;
    end;
    
    FUserManager.LoadUsersFromJSON(filename);
    
    // Reinicializar la matriz de relaciones con los nuevos usuarios
    FRelationMatrix.Free;
    FUserIndexMap.Clear;
    InitializeRelationMatrix;
    
    Result := True;
  except
    on E: Exception do
      errorMsg := 'Error al cargar usuarios: ' + E.Message;
  end;
end;

function TRootManager.CreateCommunity(nombre: string; out errorMsg: string): Boolean;
begin
  Result := FCommunityManager.CreateCommunity(nombre, errorMsg);
end;

function TRootManager.AddUserToCommunity(communityName, userEmail: string; out errorMsg: string): Boolean;
var
  community: PCommunity;
begin
  Result := False;
  errorMsg := '';
  
  community := FCommunityManager.FindCommunityByName(communityName);
  if community = nil then
  begin
    errorMsg := 'Comunidad no encontrada: ' + communityName;
    Exit;
  end;
  
  Result := FCommunityManager.AddUserToCommunity(community^.id, userEmail, errorMsg);
end;

function TRootManager.ListCommunities: TStringList;
var
  current: PCommunity;
begin
  Result := TStringList.Create;
  current := FCommunityManager.Communities.Head;
  
  while current <> nil do
  begin
    Result.Add(Format('%d - %s', [current^.id, current^.nombre]));
    current := current^.siguiente;
  end;
end;

function TRootManager.GenerateUserReport: Boolean;
var
  outputDir: string;
begin
  outputDir := GetCurrentDir + PathDelim + 'Root-Reportes';
  Result := FReportGenerator.GenerateUserReport(outputDir);
end;

function TRootManager.GenerateRelationReport: Boolean;
var
  outputDir: string;
begin
  outputDir := GetCurrentDir + PathDelim + 'Root-Reportes';
  Result := FReportGenerator.GenerateRelationReport(FRelationMatrix, outputDir);
end;

function TRootManager.GenerateCommunitiesReport: Boolean;
var
  outputDir: string;
begin
  outputDir := GetCurrentDir + PathDelim + 'Root-Reportes';
  Result := FReportGenerator.GenerateCommunitiesReport(outputDir);
end;

procedure TRootManager.RegisterEmailSent(senderEmail, receiverEmail: string);
begin
  UpdateRelationMatrix(senderEmail, receiverEmail);
end;

end.
