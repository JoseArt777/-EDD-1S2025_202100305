unit UReports;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, UStructures, UUser, UCommunities;

type
  TReportGenerator = class
  private
    FUserManager: TUserManager;
    FCommunityManager: TCommunityManager;
    
    // Métodos auxiliares para generar reportes en DOT
    function GenerateUserListDOT: string;
    function GenerateRelationMatrixDOT(matrix: TSparseMatrix): string;
    function GenerateEmailListDOT(emailList: TEmailList; title: string): string;
    function GenerateContactListDOT(contactList: TContactList): string;
    function GenerateEmailQueueDOT(emailQueue: TEmailQueue): string;
    function GenerateEmailStackDOT(emailStack: TEmailStack): string;
    function GenerateCommunityListDOT: string;
    
    // Utilidades
    procedure CreateDirectoryIfNotExists(dirPath: string);
    function SaveReportToFile(content, filename: string): Boolean;
    function GenerateGraphvizImage(dotFile, outputFile: string): Boolean;
    
  public
    constructor Create(userManager: TUserManager; communityManager: TCommunityManager);
    destructor Destroy; override;
    
    // Reportes del Root
    function GenerateUserReport(outputDir: string): Boolean;
    function GenerateRelationReport(matrix: TSparseMatrix; outputDir: string): Boolean;
    
    // Reportes del Usuario
    function GenerateReceivedEmailsReport(emailList: TEmailList; userEmail, outputDir: string): Boolean;
    function GenerateTrashReport(emailStack: TEmailStack; userEmail, outputDir: string): Boolean;
    function GenerateScheduledEmailsReport(emailQueue: TEmailQueue; userEmail, outputDir: string): Boolean;
    function GenerateContactsReport(contactList: TContactList; userEmail, outputDir: string): Boolean;
    
    // Reporte de comunidades
    function GenerateCommunitiesReport(outputDir: string): Boolean;
  end;

implementation

uses
  FileUtil, Process;

constructor TReportGenerator.Create(userManager: TUserManager; communityManager: TCommunityManager);
begin
  inherited Create;
  FUserManager := userManager;
  FCommunityManager := communityManager;
end;

destructor TReportGenerator.Destroy;
begin
  inherited Destroy;
end;

function TReportGenerator.GenerateUserListDOT: string;
var
  current: PUser;
begin
  Result := 'digraph UserList {' + LineEnding +
            '  rankdir=LR;' + LineEnding +
            '  node [shape=rectangle, style=filled, fillcolor=lightblue];' + LineEnding;
  
  current := FUserManager.Users.Head;
  while current <> nil do
  begin
    Result := Result + Format('  user%d [label="ID: %d\nNombre: %s\nUsuario: %s\nEmail: %s\nTeléfono: %s"];' + LineEnding,
                             [current^.id, current^.id, current^.nombre, current^.usuario, current^.email, current^.telefono]);
    
    if current^.siguiente <> nil then
      Result := Result + Format('  user%d -> user%d;' + LineEnding, [current^.id, current^.siguiente^.id]);
    
    current := current^.siguiente;
  end;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateRelationMatrixDOT(matrix: TSparseMatrix): string;
var
  i, j, value: Integer;
  userCurrent: PUser;
  userEmails: TStringList;
begin
  Result := 'digraph RelationMatrix {' + LineEnding +
            '  rankdir=TB;' + LineEnding +
            '  node [shape=rectangle];' + LineEnding;
  
  // Crear lista de emails de usuarios
  userEmails := TStringList.Create;
  try
    userCurrent := FUserManager.Users.Head;
    while userCurrent <> nil do
    begin
      userEmails.Add(userCurrent^.email);
      userCurrent := userCurrent^.siguiente;
    end;
    
    // Generar nodos de usuarios
    for i := 0 to userEmails.Count - 1 do
    begin
      Result := Result + Format('  user%d [label="%s", style=filled, fillcolor=lightgreen];' + LineEnding,
                               [i, userEmails[i]]);
    end;
    
    // Generar conexiones basadas en la matriz
    for i := 0 to matrix.MaxFila do
    begin
      for j := 0 to matrix.MaxColumna do
      begin
        value := matrix.GetValue(i, j);
        if value > 0 then
        begin
          Result := Result + Format('  user%d -> user%d [label="%d"];' + LineEnding,
                                   [i, j, value]);
        end;
      end;
    end;
    
  finally
    userEmails.Free;
  end;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateEmailListDOT(emailList: TEmailList; title: string): string;
var
  current: PEmail;
  nodeCount: Integer;
begin
  Result := 'digraph EmailList {' + LineEnding +
            '  rankdir=LR;' + LineEnding +
            '  label="' + title + '";' + LineEnding +
            '  node [shape=rectangle, style=filled];' + LineEnding;
  
  current := emailList.Head;
  nodeCount := 0;
  
  while current <> nil do
  begin
    Result := Result + Format('  email%d [label="ID: %d\nRemitente: %s\nEstado: %s\nProgramado: %s\nAsunto: %s\nFecha: %s\nMensaje: %s", fillcolor=lightcyan];' + LineEnding,
                             [nodeCount, current^.id, current^.remitente, current^.estado, 
                              BoolToStr(current^.programado, True), current^.asunto, 
                              DateTimeToStr(current^.fecha), current^.mensaje]);
    
    if current^.siguiente <> nil then
      Result := Result + Format('  email%d -> email%d;' + LineEnding, [nodeCount, nodeCount + 1]);
    
    current := current^.siguiente;
    Inc(nodeCount);
  end;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateContactListDOT(contactList: TContactList): string;
var
  current: PContact;
  nodeCount, firstNode: Integer;
begin
  Result := 'digraph ContactList {' + LineEnding +
            '  rankdir=LR;' + LineEnding +
            '  label="Lista Circular de Contactos";' + LineEnding +
            '  node [shape=rectangle, style=filled, fillcolor=lightpink];' + LineEnding;
  
  if contactList.Head = nil then
  begin
    Result := Result + '  empty [label="Lista vacía"];' + LineEnding;
    Result := Result + '}' + LineEnding;
    Exit;
  end;
  
  current := contactList.Head;
  nodeCount := 0;
  firstNode := 0;
  
  repeat
    Result := Result + Format('  contact%d [label="ID: %d\nNombre: %s\nUsuario: %s\nEmail: %s\nTeléfono: %s"];' + LineEnding,
                             [nodeCount, current^.id, current^.nombre, current^.usuario, current^.email, current^.telefono]);
    
    if current^.siguiente <> contactList.Head then
      Result := Result + Format('  contact%d -> contact%d;' + LineEnding, [nodeCount, nodeCount + 1])
    else
      Result := Result + Format('  contact%d -> contact%d [color=red, style=dashed];' + LineEnding, [nodeCount, firstNode]);
    
    current := current^.siguiente;
    Inc(nodeCount);
  until current = contactList.Head;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateEmailQueueDOT(emailQueue: TEmailQueue): string;
var
  current: PEmail;
  nodeCount: Integer;
begin
  Result := 'digraph EmailQueue {' + LineEnding +
            '  rankdir=LR;' + LineEnding +
            '  label="Cola de Correos Programados";' + LineEnding +
            '  node [shape=rectangle, style=filled, fillcolor=lightyellow];' + LineEnding;
  
  current := emailQueue.Head;
  nodeCount := 0;
  
  while current <> nil do
  begin
    Result := Result + Format('  email%d [label="ID: %d\nRemitente: %s\nEstado: %s\nAsunto: %s\nFecha de Envío: %s\nMensaje: %s"];' + LineEnding,
                             [nodeCount, current^.id, current^.remitente, current^.estado, 
                              current^.asunto, DateTimeToStr(current^.fecha), current^.mensaje]);
    
    if current^.siguiente <> nil then
      Result := Result + Format('  email%d -> email%d;' + LineEnding, [nodeCount, nodeCount + 1]);
    
    current := current^.siguiente;
    Inc(nodeCount);
  end;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateEmailStackDOT(emailStack: TEmailStack): string;
var
  current: PEmail;
  nodeCount: Integer;
begin
  Result := 'digraph EmailStack {' + LineEnding +
            '  rankdir=TB;' + LineEnding +
            '  label="Pila de Correos Eliminados";' + LineEnding +
            '  node [shape=rectangle, style=filled, fillcolor=lightcoral];' + LineEnding;
  
  current := emailStack.Top;
  nodeCount := 0;
  
  while current <> nil do
  begin
    Result := Result + Format('  email%d [label="ID: %d\nRemitente: %s\nEstado: %s\nProgramado: %s\nAsunto: %s\nFecha: %s\nMensaje: %s"];' + LineEnding,
                             [nodeCount, current^.id, current^.remitente, current^.estado, 
                              BoolToStr(current^.programado, True), current^.asunto, 
                              DateTimeToStr(current^.fecha), current^.mensaje]);
    
    if current^.siguiente <> nil then
      Result := Result + Format('  email%d -> email%d;' + LineEnding, [nodeCount, nodeCount + 1]);
    
    current := current^.siguiente;
    Inc(nodeCount);
  end;
  
  Result := Result + '}' + LineEnding;
end;

function TReportGenerator.GenerateCommunityListDOT: string;
var
  currentCommunity: PCommunity;
  currentUser: PUser;
  communityCount, userCount: Integer;
begin
  Result := 'digraph CommunityList {' + LineEnding +
            '  rankdir=TB;' + LineEnding +
            '  label="Reporte de Comunidades";' + LineEnding +
            '  node [shape=rectangle, style=filled];' + LineEnding;
  
  currentCommunity := FCommunityManager.Communities.Head;
  communityCount := 0;
  
  while currentCommunity <> nil do
  begin
    Result := Result + Format('  community%d [label="Comunidad %d\n%s", fillcolor=lightblue];' + LineEnding,
                             [communityCount, currentCommunity^.id, currentCommunity^.nombre]);
    
    // Agregar usuarios de la comunidad
    currentUser := currentCommunity^.usuarios;
    userCount := 0;
    while currentUser <> nil do
    begin
      Result := Result + Format('  user%d_%d [label="%s", fillcolor=lightyellow];' + LineEnding,
                               [communityCount, userCount, currentUser^.email]);
      Result := Result + Format('  community%d -> user%d_%d;' + LineEnding,
                               [communityCount, communityCount, userCount]);
      
      currentUser := currentUser^.siguiente;
      Inc(userCount);
    end;
    
    if currentCommunity^.siguiente <> nil then
      Result := Result + Format('  community%d -> community%d [style=dashed];' + LineEnding,
                               [communityCount, communityCount + 1]);
    
    currentCommunity := currentCommunity^.siguiente;
    Inc(communityCount);
  end;
  
  Result := Result + '}' + LineEnding;
end;

procedure TReportGenerator.CreateDirectoryIfNotExists(dirPath: string);
begin
  if not DirectoryExists(dirPath) then
    ForceDirectories(dirPath);
end;

function TReportGenerator.SaveReportToFile(content, filename: string): Boolean;
var
  fileStream: TFileStream;
begin
  Result := False;
  try
    fileStream := TFileStream.Create(filename, fmCreate);
    try
      fileStream.WriteBuffer(content[1], Length(content));
      Result := True;
    finally
      fileStream.Free;
    end;
  except
    on E: Exception do
      WriteLn('Error saving file: ', E.Message);
  end;
end;

function TReportGenerator.GenerateGraphvizImage(dotFile, outputFile: string): Boolean;
var
  process: TProcess;
begin
  Result := False;
  try
    process := TProcess.Create(nil);
    try
      process.Executable := 'dot';
      process.Parameters.Add('-Tpng');
      process.Parameters.Add('-o');
      process.Parameters.Add(outputFile);
      process.Parameters.Add(dotFile);
      process.Options := [poWaitOnExit];
      process.Execute;
      Result := process.ExitStatus = 0;
    finally
      process.Free;
    end;
  except
    on E: Exception do
      WriteLn('Error generating image: ', E.Message);
  end;
end;

function TReportGenerator.GenerateUserReport(outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
begin
  Result := False;
  
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateUserListDOT;
  dotFile := outputDir + PathDelim + 'reporte_usuarios.dot';
  pngFile := outputDir + PathDelim + 'reporte_usuarios.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateRelationReport(matrix: TSparseMatrix; outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
begin
  Result := False;
  
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateRelationMatrixDOT(matrix);
  dotFile := outputDir + PathDelim + 'reporte_relaciones.dot';
  pngFile := outputDir + PathDelim + 'reporte_relaciones.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateReceivedEmailsReport(emailList: TEmailList; userEmail, outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
  userName: string;
begin
  Result := False;
  
  // Obtener nombre de usuario para el directorio
  userName := Copy(userEmail, 1, Pos('@', userEmail) - 1);
  outputDir := outputDir + PathDelim + userName + '-reportes';
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateEmailListDOT(emailList, 'Correos Recibidos');
  dotFile := outputDir + PathDelim + 'reporte_correos_recibidos.dot';
  pngFile := outputDir + PathDelim + 'reporte_correos_recibidos.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateTrashReport(emailStack: TEmailStack; userEmail, outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
  userName: string;
begin
  Result := False;
  
  userName := Copy(userEmail, 1, Pos('@', userEmail) - 1);
  outputDir := outputDir + PathDelim + userName + '-reportes';
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateEmailStackDOT(emailStack);
  dotFile := outputDir + PathDelim + 'reporte_papelera.dot';
  pngFile := outputDir + PathDelim + 'reporte_papelera.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateScheduledEmailsReport(emailQueue: TEmailQueue; userEmail, outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
  userName: string;
begin
  Result := False;
  
  userName := Copy(userEmail, 1, Pos('@', userEmail) - 1);
  outputDir := outputDir + PathDelim + userName + '-reportes';
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateEmailQueueDOT(emailQueue);
  dotFile := outputDir + PathDelim + 'reporte_correos_programados.dot';
  pngFile := outputDir + PathDelim + 'reporte_correos_programados.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateContactsReport(contactList: TContactList; userEmail, outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
  userName: string;
begin
  Result := False;
  
  userName := Copy(userEmail, 1, Pos('@', userEmail) - 1);
  outputDir := outputDir + PathDelim + userName + '-reportes';
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateContactListDOT(contactList);
  dotFile := outputDir + PathDelim + 'reporte_contactos.dot';
  pngFile := outputDir + PathDelim + 'reporte_contactos.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

function TReportGenerator.GenerateCommunitiesReport(outputDir: string): Boolean;
var
  dotContent: string;
  dotFile, pngFile: string;
begin
  Result := False;
  
  CreateDirectoryIfNotExists(outputDir);
  
  dotContent := GenerateCommunityListDOT;
  dotFile := outputDir + PathDelim + 'reporte_comunidades.dot';
  pngFile := outputDir + PathDelim + 'reporte_comunidades.png';
  
  if SaveReportToFile(dotContent, dotFile) then
  begin
    Result := GenerateGraphvizImage(dotFile, pngFile);
  end;
end;

end.
