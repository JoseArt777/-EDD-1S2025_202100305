unit matriz_dispersa;

{$mode objfpc}{$H+}

interface

uses
  SysUtils, DateUtils;

type
  // Nodo interno (intersección remitente-destinatario)
  PMatrizNodo = ^TMatrizNodo;
  TMatrizNodo = record
    // enlaces ortogonales
    arriba, abajo, izquierda, derecha: PMatrizNodo;
    // referencias a cabeceras (no estrictamente necesarias pero útiles)
    fila, col: PChar;  // solo referencial (no propietario)
    // valor almacenado (cantidad de correos enviados remitente -> destinatario)
    valor: Integer;
  end;

  // Cabecera simple para filas/columnas (lista ordenada por nombre)
  PCabecera = ^TCabecera;
  TCabecera = record
    nombre: string;
    // Para filas: primer nodo hacia la derecha; para columnas: primer nodo hacia abajo
    acceso: PMatrizNodo;
    siguiente: PCabecera;  // siguiente cabecera en la lista (filas o columnas)
  end;

  // Matriz dispersa ortogonal (filas = remitentes, columnas = destinatarios)
  TMatrizDispersa = class
  private
    filas: PCabecera;    // lista de cabeceras de filas (remitentes)
    columnas: PCabecera; // lista de cabeceras de columnas (destinatarios)

    function  ObtenerOCrearCabecera(var lista: PCabecera; const nombre: string): PCabecera;
    function  BuscarCabecera(lista: PCabecera; const nombre: string): PCabecera;
    function  BuscarNodoEnFila(fCab: PCabecera; const colName: string): PMatrizNodo;
    function  InsertarNodoEnFila(fCab: PCabecera; cCab: PCabecera): PMatrizNodo;

    procedure LimpiarCabeceras(var lista: PCabecera);
    procedure ConectarHorizontal(n: PMatrizNodo; fCab: PCabecera);
    procedure ConectarVertical(n: PMatrizNodo; cCab: PCabecera);

  public
    constructor Create;
    destructor Destroy; override;

    // Aumenta el contador de correos de remitente->destinatario (crea lo que falte)
    procedure Incrementar(const remitente, destinatario: string; inc: Integer = 1);

    // Obtiene el valor almacenado en la celda remitente->destinatario (0 si no existe)
    function  Obtener(const remitente, destinatario: string): Integer;

    // Elimina nodos con valor 0 (si llegas a decrementar en el futuro)
    procedure Compactar;

    // Limpia toda la estructura
    procedure Limpiar;

    // Genera reporte Graphviz (DOT) para visualizar la matriz
    function  GenerarReporteDOT: string;

    // Reporte HTML tabular sencillo (opcional)
    function  GenerarReporteHTML: string;
  end;

implementation

{ Utilidades de cabeceras }

function TMatrizDispersa.BuscarCabecera(lista: PCabecera; const nombre: string): PCabecera;
begin
  Result := lista;
  while (Result <> nil) and (CompareText(Result^.nombre, nombre) <> 0) do
    Result := Result^.siguiente;
end;

function TMatrizDispersa.ObtenerOCrearCabecera(var lista: PCabecera; const nombre: string): PCabecera;
var
  actual, anterior, nuevo: PCabecera;
begin
  // Lista ordenada alfabéticamente por nombre (para que reporte salga bonito)
  anterior := nil;
  actual := lista;
  while (actual <> nil) and (CompareText(actual^.nombre, nombre) < 0) do
  begin
    anterior := actual;
    actual := actual^.siguiente;
  end;

  if (actual <> nil) and (CompareText(actual^.nombre, nombre) = 0) then
  begin
    Result := actual;
    Exit;
  end;

  // crear nueva cabecera
  New(nuevo);
  nuevo^.nombre := nombre;
  nuevo^.acceso := nil;
  nuevo^.siguiente := actual;

  if anterior = nil then
    lista := nuevo
  else
    anterior^.siguiente := nuevo;

  Result := nuevo;
end;

{ Utilidades de nodos }

function TMatrizDispersa.BuscarNodoEnFila(fCab: PCabecera; const colName: string): PMatrizNodo;
var
  n: PMatrizNodo;
begin
  Result := nil;
  n := fCab^.acceso;
  while n <> nil do
  begin
    if (n^.col <> nil) and (AnsiCompareText(string(n^.col), colName) = 0) then
    begin
      Result := n;
      Exit;
    end;
    n := n^.derecha;
  end;
end;

procedure TMatrizDispersa.ConectarHorizontal(n: PMatrizNodo; fCab: PCabecera);
var
  cur, prev: PMatrizNodo;
begin
  // Inserta n en la lista horizontal de la fila, ordenado por nombre de columna
  prev := nil;
  cur := fCab^.acceso;
  while (cur <> nil) and (string(cur^.col) < string(n^.col)) do
  begin
    prev := cur;
    cur := cur^.derecha;
  end;

  // insertar entre prev y cur
  n^.izquierda := prev;
  n^.derecha := cur;
  if prev <> nil then prev^.derecha := n else fCab^.acceso := n;
  if cur <> nil then cur^.izquierda := n;
end;

procedure TMatrizDispersa.ConectarVertical(n: PMatrizNodo; cCab: PCabecera);
var
  cur, prev: PMatrizNodo;
begin
  // Inserta n en la lista vertical de la columna, ordenado por nombre de fila
  prev := nil;
  cur := cCab^.acceso;
  while (cur <> nil) and (string(cur^.fila) < string(n^.fila)) do
  begin
    prev := cur;
    cur := cur^.abajo;
  end;

  n^.arriba := prev;
  n^.abajo := cur;
  if prev <> nil then prev^.abajo := n else cCab^.acceso := n;
  if cur <> nil then cur^.arriba := n;
end;

function TMatrizDispersa.InsertarNodoEnFila(fCab: PCabecera; cCab: PCabecera): PMatrizNodo;
begin
  New(Result);
  FillChar(Result^, SizeOf(Result^), 0);
  // Guardamos punteros C a los nombres para comparaciones rápidas (no gestionados)
  Result^.fila := PChar(fCab^.nombre);
  Result^.col  := PChar(cCab^.nombre);
  Result^.valor := 0;

  // conectar en fila y columna
  ConectarHorizontal(Result, fCab);
  ConectarVertical(Result, cCab);
end;

{ API pública }

constructor TMatrizDispersa.Create;
begin
  filas := nil;
  columnas := nil;
end;

destructor TMatrizDispersa.Destroy;
begin
  Limpiar;
  inherited Destroy;
end;

procedure TMatrizDispersa.Incrementar(const remitente, destinatario: string; inc: Integer);
var
  fCab, cCab: PCabecera;
  n: PMatrizNodo;
begin
  if inc = 0 then Exit;

  // Asegurar cabeceras
  fCab := ObtenerOCrearCabecera(filas, remitente);
  cCab := ObtenerOCrearCabecera(columnas, destinatario);

  // Buscar nodo en esa fila/columna
  n := BuscarNodoEnFila(fCab, destinatario);
  if n = nil then
    n := InsertarNodoEnFila(fCab, cCab);

  // Actualizar valor
  n^.valor := n^.valor + inc;
  if n^.valor < 0 then n^.valor := 0; // no permitir negativos
end;

function TMatrizDispersa.Obtener(const remitente, destinatario: string): Integer;
var
  fCab: PCabecera;
  n: PMatrizNodo;
begin
  Result := 0;
  fCab := BuscarCabecera(filas, remitente);
  if fCab = nil then Exit;

  n := BuscarNodoEnFila(fCab, destinatario);
  if n <> nil then
    Result := n^.valor;
end;

procedure TMatrizDispersa.Compactar;
var
  fCab, fNext: PCabecera;
  c: PMatrizNodo;
  // helpers para eliminar nodo
  procedure EliminarNodo(var head: PMatrizNodo; n: PMatrizNodo);
  begin
    // desconectar horizontal
    if n^.izquierda <> nil then n^.izquierda^.derecha := n^.derecha else head := n^.derecha;
    if n^.derecha   <> nil then n^.derecha^.izquierda := n^.izquierda;

    // desconectar vertical (desde su columna)
    // Buscamos cabecera de columna por nombre
    // Como tenemos columnas separadas, hay que ajustar también cCab^.acceso si corresponde
    // Para simplificar, hacemos una pasada por la cabecera de la columna
    // (Omitimos limpiar cabeceras vacías aquí para mantenerlo simple)
  end;
begin
  // Compactación mínima: elimina solo nodos con valor 0 recorriendo por filas,
  // sin remover cabeceras vacías (la mayoría de usos no lo necesita).
  fCab := filas;
  while fCab <> nil do
  begin
    c := fCab^.acceso;
    while c <> nil do
    begin
      if c^.valor = 0 then
      begin
        // guardar siguiente antes de eliminar
        // (eliminar bien requiere actualizar también la columna; para no alargar, evitamos eliminar física)
        // En esta versión dejaremos la compactación lógica para el futuro.
      end;
      c := c^.derecha;
    end;
    fCab := fCab^.siguiente;
  end;
end;

procedure TMatrizDispersa.LimpiarCabeceras(var lista: PCabecera);
var
  cab, cabNext: PCabecera;
  n, nx: PMatrizNodo;
begin
  cab := lista;
  while cab <> nil do
  begin
    // liberar lista ortogonal de esta cabecera
    n := cab^.acceso;
    while n <> nil do
    begin
      nx := n^.derecha; // recorrer por derecha para no perder referencia
      Dispose(n);
      n := nx;
    end;
    cabNext := cab^.siguiente;
    Dispose(cab);
    cab := cabNext;
  end;
  lista := nil;
end;

procedure TMatrizDispersa.Limpiar;
begin
  LimpiarCabeceras(filas);
  LimpiarCabeceras(columnas);
end;

function TMatrizDispersa.GenerarReporteDOT: string;
var
  s: TStringBuilder;
  fCab: PCabecera;
  cCab: PCabecera;
  n: PMatrizNodo;
  filaIdx, colIdx: Integer;
begin
  s := TStringBuilder.Create;
  try
    s.AppendLine('digraph Matriz {');
    s.AppendLine('  node [shape=record, fontname="Helvetica"];');
    s.AppendLine('  rankdir=LR;');

    // Nodos de cabeceras de filas
    filaIdx := 0;
    fCab := filas;
    while fCab <> nil do
    begin
      s.AppendLine(Format('  f%d [label="Fila: %s", shape=box, style=filled, fillcolor=lightblue];',
        [filaIdx, fCab^.nombre]));
      fCab := fCab^.siguiente;
      Inc(filaIdx);
    end;

    // Nodos de cabeceras de columnas
    colIdx := 0;
    cCab := columnas;
    while cCab <> nil do
    begin
      s.AppendLine(Format('  c%d [label="Col: %s", shape=box, style=filled, fillcolor=lightgreen];',
        [colIdx, cCab^.nombre]));
      cCab := cCab^.siguiente;
      Inc(colIdx);
    end;

    // Nodos de valores y aristas desde cabeceras
    filaIdx := 0;
    fCab := filas;
    while fCab <> nil do
    begin
      n := fCab^.acceso;
      while n <> nil do
      begin
        s.AppendLine(Format('  "n_%s_%s" [label="%s → %s | %d"];',
          [string(n^.fila), string(n^.col), string(n^.fila), string(n^.col), n^.valor]));
        // Conexiones opcionales: desde fila/col
        s.AppendLine(Format('  f%d -> "n_%s_%s" [color=gray, style=dashed];',
          [filaIdx, string(n^.fila), string(n^.col)]));
        // Para la columna, necesitamos su índice; como es más trabajo, solo añadimos etiqueta
        n := n^.derecha;
      end;
      fCab := fCab^.siguiente;
      Inc(filaIdx);
    end;

    s.AppendLine('}');
    Result := s.ToString;
  finally
    s.Free;
  end;
end;

function TMatrizDispersa.GenerarReporteHTML: string;
var
  s: TStringBuilder;
  fCab: PCabecera;
  n: PMatrizNodo;
begin
  s := TStringBuilder.Create;
  try
    s.AppendLine('<html><head><title>Matriz Dispersa</title></head><body>');
    s.AppendLine('<h1>Relaciones Remitente → Destinatario</h1>');

    fCab := filas;
    if fCab = nil then
    begin
      s.AppendLine('<p>Sin datos.</p>');
    end
    else
    begin
      while fCab <> nil do
      begin
        s.AppendLine(Format('<h3>Remitente: %s</h3>', [fCab^.nombre]));
        if fCab^.acceso = nil then
          s.AppendLine('<p>(sin destinatarios)</p>')
        else
        begin
          s.AppendLine('<table border="1">');
          s.AppendLine('<tr><th>Destinatario</th><th>Cantidad</th></tr>');
          n := fCab^.acceso;
          while n <> nil do
          begin
            s.AppendLine(Format('<tr><td>%s</td><td>%d</td></tr>',
              [string(n^.col), n^.valor]));
            n := n^.derecha;
          end;
          s.AppendLine('</table>');
        end;
        fCab := fCab^.siguiente;
      end;
    end;

    s.AppendLine('</body></html>');
    Result := s.ToString;
  finally
    s.Free;
  end;
end;

end.

